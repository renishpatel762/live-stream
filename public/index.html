<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Streaming Platform</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .control-group {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .control-group h3 {
            margin-bottom: 15px;
            color: #ffd700;
        }

        button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            margin: 5px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .success {
            background: linear-gradient(45deg, #2dd36f, #10dc60);
        }

        .warning {
            background: linear-gradient(45deg, #ffc409, #ffab00);
        }

        .danger {
            background: linear-gradient(45deg, #dc3545, #c82333);
        }

        .info {
            background: linear-gradient(45deg, #17a2b8, #138496);
        }

        input[type="text"], select {
            padding: 10px;
            border: none;
            border-radius: 10px;
            margin: 5px;
            font-size: 1rem;
            background: rgba(255,255,255,0.9);
            color: #333;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }

        .checkbox-container input[type="checkbox"] {
            margin-right: 10px;
            transform: scale(1.2);
        }

        .video-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .video-section {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .video-section h3 {
            margin-bottom: 15px;
            color: #ffd700;
        }

        video {
            width: 100%;
            height: 300px;
            border-radius: 10px;
            background: #000;
            object-fit: cover;
        }

        .status {
            margin-top: 15px;
            padding: 10px;
            border-radius: 10px;
            font-weight: bold;
            text-align: center;
        }

        .status.connected {
            background: rgba(45, 211, 111, 0.3);
            border: 1px solid #2dd36f;
        }

        .status.streaming {
            background: rgba(255, 193, 7, 0.3);
            border: 1px solid #ffc107;
        }

        .status.error {
            background: rgba(220, 53, 69, 0.3);
            border: 1px solid #dc3545;
        }

        .streams-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .streams-list {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .streams-list h3 {
            margin-bottom: 15px;
            color: #ffd700;
        }

        .stream-item {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .stream-info {
            flex: 1;
        }

        .stream-name {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stream-details {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .stream-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .stream-actions button {
            padding: 8px 16px;
            font-size: 0.9rem;
        }

        .viewer-count {
            background: rgba(255,255,255,0.2);
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            margin-left: 10px;
        }

        .quality-selector {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }

        .quality-selector select {
            background: rgba(255,255,255,0.9);
            color: #333;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.9rem;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .tab {
            padding: 10px 20px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .tab.active {
            background: rgba(255,255,255,0.3);
            border-color: #ffd700;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .debug-info {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            font-family: monospace;
            font-size: 0.9rem;
            max-height: 400px;
            overflow-y: scroll;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #ffd700;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.8;
            margin-top: 5px;
        }

        @media (max-width: 768px) {
            .video-container, .streams-container {
                grid-template-columns: 1fr;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .control-group {
                width: 100%;
                max-width: 400px;
            }
            
            .stream-item {
                flex-direction: column;
                align-items: stretch;
            }
            
            .stream-actions {
                margin-top: 10px;
                justify-content: center;
            }
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .alert {
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 10px;
            border: 1px solid transparent;
        }

        .alert.success {
            background: rgba(45, 211, 111, 0.2);
            border-color: #2dd36f;
            color: #d4edda;
        }

        .alert.error {
            background: rgba(220, 53, 69, 0.2);
            border-color: #dc3545;
            color: #f8d7da;
        }

        .alert.info {
            background: rgba(23, 162, 184, 0.2);
            border-color: #17a2b8;
            color: #d1ecf1;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üé• Live Streaming Platform</h1>
            <p>Real-time HLS streaming with multiple quality options and archiving</p>
        </div>

        <div class="stats">
            <div class="stat-card">
                <div class="stat-value" id="activeStreamsCount">0</div>
                <div class="stat-label">Active Streams</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="archivedStreamsCount">0</div>
                <div class="stat-label">Archived Streams</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="totalViewers">0</div>
                <div class="stat-label">Total Viewers</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="connectionStatus">‚óè</div>
                <div class="stat-label">Connection</div>
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <h3>üé¨ Start Broadcasting</h3>
                <div style="display: flex; align-items: center; margin-bottom: 10px; flex-wrap: wrap;">
                    <input type="text" id="streamName" placeholder="Enter stream name..." value="My Live Stream">
                    <button id="startStreamBtn">Start Stream</button>
                </div>
                <div class="checkbox-container">
                    <input type="checkbox" id="preserveAfterStop" checked>
                    <label for="preserveAfterStop">Archive stream after stopping</label>
                </div>
                <button id="stopStreamBtn" disabled class="warning">Stop Stream</button>
            </div>

            <div class="control-group">
                <h3>üéÆ Controls</h3>
                <button id="refreshStreamsBtn" class="info">Refresh Streams</button>
                <button id="loadArchivedBtn" class="info">Load Archived</button>
                <button id="clearDebugBtn" class="warning">Clear Debug</button>
                <button id="checkFFmpegBtn" class="success">Check FFmpeg</button>
            </div>
        </div>

        <div class="video-container">
            <div class="video-section">
                <h3>üìπ Your Stream (Broadcasting)</h3>
                <video id="localVideo" autoplay muted playsinline></video>
                <div id="streamStatus" class="status">Ready to stream</div>
                <div class="quality-selector">
                    <span>Streaming Quality:</span>
                    <select id="streamQuality">
                        <option value="720p">720p (1280x720)</option>
                        <option value="480p">480p (854x480)</option>
                        <option value="360p">360p (640x360)</option>
                    </select>
                </div>
            </div>

            <div class="video-section">
                <h3>üëÄ Watching Stream</h3>
                <video id="remoteVideo" controls playsinline></video>
                <div id="viewerStatus" class="status">Select a stream to watch</div>
                <div class="quality-selector">
                    <span>Playback Quality:</span>
                    <select id="playbackQuality">
                        <option value="auto">Auto</option>
                        <option value="720p">720p</option>
                        <option value="480p">480p</option>
                        <option value="360p">360p</option>
                    </select>
                    <button id="changeQualityBtn" class="info">Change Quality</button>
                </div>
            </div>
        </div>

        <div class="streams-container">
            <div class="streams-list">
                <div class="tabs">
                    <div class="tab active" data-tab="live">üî¥ Live Streams</div>
                    <div class="tab" data-tab="archived">üìÅ Archived Streams</div>
                </div>
                
                <div class="tab-content active" id="live-tab">
                    <div id="activeStreams">
                        <p style="text-align: center; opacity: 0.7;">No active streams</p>
                    </div>
                </div>
                
                <div class="tab-content" id="archived-tab">
                    <div id="archivedStreams">
                        <p style="text-align: center; opacity: 0.7;">No archived streams</p>
                    </div>
                </div>
            </div>

            <div class="streams-list">
                <h3>üìä Debug Information</h3>
                <div id="debugInfo" class="debug-info">
                    <div>System ready...</div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/hls.js/1.4.12/hls.min.js"></script>
    <script>
        class LiveStreamingClient {
            constructor() {
                this.ws = null;
                this.localStream = null;
                this.mediaRecorder = null;
                this.currentStreamId = null;
                this.isStreaming = false;
                this.currentWatchingStream = null;
                this.hlsPlayer = null;
                this.chunkCount = 0;
                this.totalBytes = 0;
                this.stats = {
                    activeStreams: 0,
                    archivedStreams: 0,
                    totalViewers: 0
                };
                
                this.initializeElements();
                this.setupEventListeners();
                this.setupTabs();
                this.connect();
            }

            initializeElements() {
                this.startStreamBtn = document.getElementById('startStreamBtn');
                this.stopStreamBtn = document.getElementById('stopStreamBtn');
                this.streamNameInput = document.getElementById('streamName');
                this.preserveAfterStopCheckbox = document.getElementById('preserveAfterStop');
                this.localVideo = document.getElementById('localVideo');
                this.remoteVideo = document.getElementById('remoteVideo');
                this.streamStatus = document.getElementById('streamStatus');
                this.viewerStatus = document.getElementById('viewerStatus');
                this.activeStreamsDiv = document.getElementById('activeStreams');
                this.archivedStreamsDiv = document.getElementById('archivedStreams');
                this.debugInfo = document.getElementById('debugInfo');
                this.streamQuality = document.getElementById('streamQuality');
                this.playbackQuality = document.getElementById('playbackQuality');
                this.changeQualityBtn = document.getElementById('changeQualityBtn');
                this.refreshStreamsBtn = document.getElementById('refreshStreamsBtn');
                this.loadArchivedBtn = document.getElementById('loadArchivedBtn');
                this.clearDebugBtn = document.getElementById('clearDebugBtn');
                this.checkFFmpegBtn = document.getElementById('checkFFmpegBtn');
                
                // Stats elements
                this.activeStreamsCountEl = document.getElementById('activeStreamsCount');
                this.archivedStreamsCountEl = document.getElementById('archivedStreamsCount');
                this.totalViewersEl = document.getElementById('totalViewers');
                this.connectionStatusEl = document.getElementById('connectionStatus');
            }

            setupEventListeners() {
                this.startStreamBtn.addEventListener('click', () => this.startStreaming());
                this.stopStreamBtn.addEventListener('click', () => this.stopStreaming());
                this.refreshStreamsBtn.addEventListener('click', () => this.refreshStreams());
                this.loadArchivedBtn.addEventListener('click', () => this.loadArchivedStreams());
                this.clearDebugBtn.addEventListener('click', () => this.clearDebugInfo());
                this.checkFFmpegBtn.addEventListener('click', () => this.checkFFmpegStatus());
                this.changeQualityBtn.addEventListener('click', () => this.changePlaybackQuality());
            }

            setupTabs() {
                const tabs = document.querySelectorAll('.tab');
                tabs.forEach(tab => {
                    tab.addEventListener('click', () => {
                        const tabId = tab.getAttribute('data-tab');
                        this.switchTab(tabId);
                    });
                });
            }

            switchTab(tabId) {
                // Update tab buttons
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                document.querySelector(`[data-tab="${tabId}"]`).classList.add('active');
                
                // Update tab content
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                document.getElementById(`${tabId}-tab`).classList.add('active');
                
                // Load archived streams when switching to archived tab
                if (tabId === 'archived') {
                    this.loadArchivedStreams();
                }
            }

            async connect() {
                try {
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    const wsUrl = `${protocol}//${window.location.host}`;
                    
                    this.ws = new WebSocket(wsUrl);
                    
                    this.ws.onopen = () => {
                        console.log('Connected to server');
                        this.updateConnectionStatus('connected');
                        this.updateDebugInfo('Connected to server');
                    };
                    
                    this.ws.onmessage = (event) => {
                        const message = JSON.parse(event.data);
                        this.handleMessage(message);
                    };
                    
                    this.ws.onclose = () => {
                        console.log('Disconnected from server');
                        this.updateConnectionStatus('disconnected');
                        this.updateDebugInfo('Disconnected from server, reconnecting...');
                        setTimeout(() => this.connect(), 3000);
                    };
                    
                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        this.updateConnectionStatus('error');
                        this.updateDebugInfo('WebSocket error occurred');
                    };
                    
                } catch (error) {
                    console.error('Connection error:', error);
                    this.updateConnectionStatus('error');
                    this.updateDebugInfo(`Connection failed: ${error.message}`);
                }
            }

            handleMessage(message) {
                console.log('Received message:', message);
                
                switch (message.type) {
                    case 'stream-started':
                        this.currentStreamId = message.streamId;
                        this.isStreaming = true;
                        this.updateStreamStatus('üî¥ Streaming Live', 'streaming');
                        this.startStreamBtn.disabled = true;
                        this.stopStreamBtn.disabled = false;
                        this.updateDebugInfo(`Stream started: ${message.streamName} (ID: ${message.streamId})`);
                        break;
                        
                    case 'stream-stopped':
                        this.isStreaming = false;
                        this.currentStreamId = null;
                        this.updateStreamStatus('Stream Stopped', 'connected');
                        this.startStreamBtn.disabled = false;
                        this.stopStreamBtn.disabled = true;
                        this.updateDebugInfo(`Stream stopped (Archived: ${message.archived})`);
                        break;
                        
                    case 'stream-error':
                        this.updateStreamStatus(`Error: ${message.error}`, 'error');
                        this.startStreamBtn.disabled = false;
                        this.stopStreamBtn.disabled = true;
                        this.isStreaming = false;
                        this.updateDebugInfo(`Stream error: ${message.error}`);
                        break;
                        
                    case 'active-streams':
                        this.updateActiveStreams(message.streams);
                        break;
                        
                    case 'archived-streams':
                        this.updateArchivedStreams(message.streams);
                        break;
                        
                    case 'new-stream':
                        this.addStreamToList(message.stream, 'active');
                        break;
                        
                    case 'stream-ended':
                        this.removeStreamFromList(message.streamId, 'active');
                        if (this.currentWatchingStream === message.streamId) {
                            this.stopWatching();
                        }
                        this.updateDebugInfo(`Stream ended: ${message.streamId} (Archived: ${message.archived})`);
                        break;
                        
                    case 'viewer-count-update':
                        this.updateViewerCount(message.streamId, message.viewers);
                        break;
                        
                    case 'joined-stream':
                        this.startWatching(message.hlsUrl, message.streamName, message.availableQualities);
                        this.updateDebugInfo(`Joined stream: ${message.streamName}`);
                        break;
                        
                    case 'quality-changed':
                        this.updateDebugInfo(`Quality changed to: ${message.quality}`);
                        break;
                        
                    case 'stream-live':
                        this.updateDebugInfo(`Stream ${message.streamId} is now live`);
                        break;
                        
                    case 'stream-not-found':
                        this.updateViewerStatus('Stream not found', 'error');
                        this.updateDebugInfo(`Stream not found: ${message.streamId}`);
                        break;
                        
                    case 'left-stream':
                        this.stopWatching();
                        this.updateDebugInfo('Left stream');
                        break;
                }
            }

            async startStreaming() {
                try {
                    const streamName = this.streamNameInput.value.trim() || 'My Live Stream';
                    const preserveAfterStop = this.preserveAfterStopCheckbox.checked;
                    
                    this.updateDebugInfo('Requesting camera access...');
                    
                    // Get user media with optimized settings
                    this.localStream = await navigator.mediaDevices.getUserMedia({
                        video: { 
                            width: { ideal: 1280 }, 
                            height: { ideal: 720 },
                            frameRate: { ideal: 30 }
                        },
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            sampleRate: 44100
                        }
                    });
                    
                    this.localVideo.srcObject = this.localStream;
                    this.updateDebugInfo('Camera access granted');
                    
                    // Check if MediaRecorder supports the format
                    const mimeType = 'video/webm;codecs=vp8,opus';
                    if (!MediaRecorder.isTypeSupported(mimeType)) {
                        throw new Error('WebM format not supported');
                    }
                    
                    // Setup MediaRecorder with optimized settings
                    this.mediaRecorder = new MediaRecorder(this.localStream, {
                        mimeType: mimeType,
                        videoBitsPerSecond: 2000000, // 2 Mbps
                        audioBitsPerSecond: 128000   // 128 kbps
                    });
                    
                    this.chunkCount = 0;
                    this.totalBytes = 0;
                    
                    this.mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0 && this.ws?.readyState === WebSocket.OPEN) {
                            this.chunkCount++;
                            this.totalBytes += event.data.size;
                            this.sendVideoChunk(event.data);
                        }
                    };
                    
                    this.mediaRecorder.onstart = () => {
                        this.updateDebugInfo('MediaRecorder started');
                    };
                    
                    this.mediaRecorder.onstop = () => {
                        this.updateDebugInfo('MediaRecorder stopped');
                    };
                    
                    this.mediaRecorder.onerror = (event) => {
                        console.error('MediaRecorder error:', event.error);
                        this.updateDebugInfo(`MediaRecorder error: ${event.error}`);
                    };
                    
                    // Start recording with shorter chunks for better real-time performance
                    this.mediaRecorder.start(100); // 100ms chunks
                    this.updateDebugInfo('MediaRecorder started with 500ms chunks');
                    
                    // Tell server to start live stream
                    this.ws.send(JSON.stringify({
                        type: 'start-live-stream',
                        streamName: streamName,
                        preserveAfterStop: preserveAfterStop
                    }));
                    
                    this.updateStreamStatus('üü° Starting stream...', 'streaming');
                    this.startStreamBtn.disabled = true;
                    
                } catch (error) {
                    console.error('Error starting stream:', error);
                    this.updateStreamStatus(`Error: ${error.message}`, 'error');
                    this.updateDebugInfo(`Error starting stream: ${error.message}`);
                }
            }

            async sendVideoChunk(data) {
                try {
                    const arrayBuffer = await data.arrayBuffer();
                    const uint8Array = new Uint8Array(arrayBuffer);
                    
                    // Convert to base64 - more efficient approach
                    let binary = '';
                    const chunkSize = 0x8000; // 32KB chunks
                    for (let i = 0; i < uint8Array.length; i += chunkSize) {
                        binary += String.fromCharCode.apply(null, uint8Array.subarray(i, i + chunkSize));
                    }
                    const base64 = btoa(binary);
                    
                    if (this.ws?.readyState === WebSocket.OPEN) {
                        this.ws.send(JSON.stringify({
                            type: 'live-video-chunk',
                            data: base64,
                            timestamp: Date.now()
                        }));
                    }
                } catch (error) {
                    console.error('Error sending video chunk:', error);
                    this.updateDebugInfo(`Error sending chunk: ${error.message}`);
                }
            }

            stopStreaming() {
                if (this.mediaRecorder) {
                    this.mediaRecorder.stop();
                    this.mediaRecorder = null;
                }
                
                if (this.localStream) {
                    this.localStream.getTracks().forEach(track => track.stop());
                    this.localStream = null;
                }
                
                this.localVideo.srcObject = null;
                
                if (this.ws?.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({
                        type: 'stop-live-stream'
                    }));
                }
                
                this.updateStreamStatus('Stream Stopped', 'connected');
                this.startStreamBtn.disabled = false;
                this.stopStreamBtn.disabled = true;
                this.isStreaming = false;
                this.currentStreamId = null;
                this.updateDebugInfo('Stream stopped manually');
            }

            joinStream(streamId, isArchived = false) {
                if (this.ws?.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({
                        type: 'join-stream',
                        streamId: streamId,
                        quality: this.playbackQuality.value === 'auto' ? '720p' : this.playbackQuality.value
                    }));
                    this.currentWatchingStream = streamId;
                    this.updateViewerStatus('üü° Connecting to stream...', 'streaming');
                }
            }

            leaveStream() {
                if (this.ws?.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({
                        type: 'leave-stream'
                    }));
                }
                this.currentWatchingStream = null;
                this.updateViewerStatus('Disconnected from stream', 'connected');
            }

            startWatching(hlsUrl, streamName, availableQualities = []) {
                if (this.hlsPlayer) {
                    this.hlsPlayer.destroy();
                }
                
                this.updateViewerStatus(`üü° Loading ${streamName}...`, 'streaming');
                this.updateDebugInfo(`Loading HLS stream: ${hlsUrl}`);
                
                if (Hls.isSupported()) {
                    this.hlsPlayer = new Hls({
                        enableWorker: false,
                        lowLatencyMode: true,
                        backBufferLength: 90
                    });
                    
                    this.hlsPlayer.loadSource(hlsUrl);
                    this.hlsPlayer.attachMedia(this.remoteVideo);
                    
                    this.hlsPlayer.on(Hls.Events.MANIFEST_PARSED, () => {
                        this.updateViewerStatus(`üü¢ Watching: ${streamName}`, 'connected');
                        this.updateDebugInfo(`Stream loaded successfully: ${streamName}`);
                        this.remoteVideo.play();
                    });
                    
                    this.hlsPlayer.on(Hls.Events.ERROR, (event, data) => {
                        console.error('HLS error:', data);
                        this.updateViewerStatus(`Error loading stream: ${data.details}`, 'error');
                        this.updateDebugInfo(`HLS error: ${data.type} - ${data.details}`);
                    });
                    
                } else if (this.remoteVideo.canPlayType('application/vnd.apple.mpegurl')) {
                    this.remoteVideo.src = hlsUrl;
                    this.remoteVideo.addEventListener('loadedmetadata', () => {
                        this.updateViewerStatus(`üü¢ Watching: ${streamName}`, 'connected');
                        this.updateDebugInfo(`Stream loaded successfully: ${streamName}`);
                    });
                    
                    this.remoteVideo.addEventListener('error', (e) => {
                        this.updateViewerStatus('Error loading stream', 'error');
                        this.updateDebugInfo(`Video error: ${e.message}`);
                    });
                }
            }

            stopWatching() {
                if (this.hlsPlayer) {
                    this.hlsPlayer.destroy();
                    this.hlsPlayer = null;
                }
                
                this.remoteVideo.src = '';
                this.remoteVideo.load();
                this.updateViewerStatus('Select a stream to watch', 'connected');
                this.currentWatchingStream = null;
            }

            changePlaybackQuality() {
                if (this.currentWatchingStream && this.ws?.readyState === WebSocket.OPEN) {
                    const newQuality = this.playbackQuality.value === 'auto' ? '720p' : this.playbackQuality.value;
                    this.ws.send(JSON.stringify({
                        type: 'change-quality',
                        streamId: this.currentWatchingStream,
                        quality: newQuality
                    }));
                    this.updateDebugInfo(`Changing quality to: ${newQuality}`);
                }
            }

            refreshStreams() {
                if (this.ws?.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({
                        type: 'get-active-streams'
                    }));
                    this.updateDebugInfo('Refreshing active streams...');
                }
            }

            loadArchivedStreams() {
                if (this.ws?.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({
                        type: 'get-archived-streams'
                    }));
                    this.updateDebugInfo('Loading archived streams...');
                }
            }

            checkFFmpegStatus() {
                if (this.ws?.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({
                        type: 'check-ffmpeg'
                    }));
                    this.updateDebugInfo('Checking FFmpeg status...');
                }
            }

            updateActiveStreams(streams) {
                this.stats.activeStreams = streams.length;
                this.updateStats();
                
                if (streams.length === 0) {
                    this.activeStreamsDiv.innerHTML = '<p style="text-align: center; opacity: 0.7;">No active streams</p>';
                    return;
                }
                
                this.activeStreamsDiv.innerHTML = streams.map(stream => this.createStreamItem(stream, false)).join('');
            }

            updateArchivedStreams(streams) {
                this.stats.archivedStreams = streams.length;
                this.updateStats();
                
                if (streams.length === 0) {
                    this.archivedStreamsDiv.innerHTML = '<p style="text-align: center; opacity: 0.7;">No archived streams</p>';
                    return;
                }
                
                this.archivedStreamsDiv.innerHTML = streams.map(stream => this.createStreamItem(stream, true)).join('');
            }

            createStreamItem(stream, isArchived) {
                const duration = isArchived ? this.formatDuration(stream.duration) : this.formatDuration(Date.now() - stream.startTime);
                const status = isArchived ? 'Archived' : 'Live';
                const statusClass = isArchived ? 'archived' : 'live';
                
                return `
                    <div class="stream-item">
                        <div class="stream-info">
                            <div class="stream-name">${stream.name}</div>
                            <div class="stream-details">
                                ${status} ‚Ä¢ ${duration}
                                ${!isArchived && stream.viewers !== undefined ? `<span class="viewer-count">${stream.viewers} viewers</span>` : ''}
                            </div>
                        </div>
                        <div class="stream-actions">
                            <button onclick="app.joinStream('${stream.id}', ${isArchived})" class="success">
                                ${isArchived ? 'Play' : 'Watch'}
                            </button>
                            ${isArchived ? `<button onclick="app.deleteArchivedStream('${stream.id}')" class="danger">Delete</button>` : ''}
                        </div>
                    </div>
                `;
            }

            deleteArchivedStream(streamId) {
                if (confirm('Are you sure you want to delete this archived stream?')) {
                    if (this.ws?.readyState === WebSocket.OPEN) {
                        this.ws.send(JSON.stringify({
                            type: 'delete-archived-stream',
                            streamId: streamId
                        }));
                        this.updateDebugInfo(`Deleting archived stream: ${streamId}`);
                    }
                }
            }

            addStreamToList(stream, type) {
                const item = this.createStreamItem(stream, type === 'archived');
                const container = type === 'archived' ? this.archivedStreamsDiv : this.activeStreamsDiv;
                
                if (container.innerHTML.includes('No active streams') || container.innerHTML.includes('No archived streams')) {
                    container.innerHTML = '';
                }
                
                container.insertAdjacentHTML('beforeend', item);
                
                if (type === 'active') {
                    this.stats.activeStreams++;
                } else {
                    this.stats.archivedStreams++;
                }
                this.updateStats();
            }

            removeStreamFromList(streamId, type) {
                const container = type === 'archived' ? this.archivedStreamsDiv : this.activeStreamsDiv;
                const items = container.querySelectorAll('.stream-item');
                
                items.forEach(item => {
                    const button = item.querySelector('button');
                    if (button && button.onclick.toString().includes(streamId)) {
                        item.remove();
                        if (type === 'active') {
                            this.stats.activeStreams--;
                        } else {
                            this.stats.archivedStreams--;
                        }
                        this.updateStats();
                    }
                });
                
                if (container.children.length === 0) {
                    const message = type === 'archived' ? 'No archived streams' : 'No active streams';
                    container.innerHTML = `<p style="text-align: center; opacity: 0.7;">${message}</p>`;
                }
            }

            updateViewerCount(streamId, viewers) {
                const viewerSpans = document.querySelectorAll('.viewer-count');
                viewerSpans.forEach(span => {
                    const item = span.closest('.stream-item');
                    const button = item.querySelector('button');
                    if (button && button.onclick.toString().includes(streamId)) {
                        span.textContent = `${viewers} viewers`;
                    }
                });
                
                // Update total viewers
                this.stats.totalViewers = viewers;
                this.updateStats();
            }

            updateStreamStatus(message, type) {
                this.streamStatus.textContent = message;
                this.streamStatus.className = `status ${type}`;
            }

            updateViewerStatus(message, type) {
                this.viewerStatus.textContent = message;
                this.viewerStatus.className = `status ${type}`;
            }

            updateConnectionStatus(status) {
                const statusMap = {
                    connected: { symbol: 'üü¢', color: '#2dd36f' },
                    streaming: { symbol: 'üü°', color: '#ffc107' },
                    disconnected: { symbol: 'üî¥', color: '#dc3545' },
                    error: { symbol: '‚ùå', color: '#dc3545' }
                };
                
                const statusInfo = statusMap[status] || statusMap.disconnected;
                this.connectionStatusEl.textContent = statusInfo.symbol;
                this.connectionStatusEl.style.color = statusInfo.color;
            }

            updateStats() {
                this.activeStreamsCountEl.textContent = this.stats.activeStreams;
                this.archivedStreamsCountEl.textContent = this.stats.archivedStreams;
                this.totalViewersEl.textContent = this.stats.totalViewers;
            }

            updateDebugInfo(message) {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = `[${timestamp}] ${message}`;
                
                const newEntry = document.createElement('div');
                newEntry.textContent = logEntry;
                this.debugInfo.appendChild(newEntry);
                
                // Keep only last 100 entries
                while (this.debugInfo.children.length > 100) {
                    this.debugInfo.removeChild(this.debugInfo.firstChild);
                }
                
                // Auto-scroll to bottom
                this.debugInfo.scrollTop = this.debugInfo.scrollHeight;
            }

            clearDebugInfo() {
                this.debugInfo.innerHTML = '<div>Debug cleared...</div>';
            }

            formatDuration(ms) {
                const seconds = Math.floor(ms / 1000);
                const minutes = Math.floor(seconds / 60);
                const hours = Math.floor(minutes / 60);
                
                if (hours > 0) {
                    return `${hours}h ${minutes % 60}m`;
                } else if (minutes > 0) {
                    return `${minutes}m ${seconds % 60}s`;
                } else {
                    return `${seconds}s`;
                }
            }
        }

        // Initialize the application
        let app;
        document.addEventListener('DOMContentLoaded', () => {
            app = new LiveStreamingClient();
        });
    </script>
</body>
</html>